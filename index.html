<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>J.A.R.V.I.S. | STARK INDUSTRIES</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000;
            font-family: 'Segoe UI', sans-serif;
        }
        
        .input_video { display: none; }

        /* 电影质感覆盖层 */
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 2;
        }

        #scan-line {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 10px;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            animation: scan 4s infinite linear;
            pointer-events: none;
            z-index: 3;
            opacity: 0.3;
        }

        @keyframes scan {
            0% { top: -10%; opacity: 0; }
            50% { opacity: 0.5; }
            100% { top: 110%; opacity: 0; }
        }

        /* 启动按钮 */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #00ffff;
        }
        
        button {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-size: 16px;
            letter-spacing: 5px;
            text-transform: uppercase;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 50px rgba(0, 255, 255, 1);
        }

        /* HUD 文字 */
        .hud-info {
            position: absolute;
            color: rgba(0, 255, 255, 0.6);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 5;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="vignette"></div>
    <div id="scan-line"></div>
    
    <div id="loader">
        <div style="font-size: 40px; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">J.A.R.V.I.S.</div>
        <button id="startBtn">INITIATE PROTOCOL</button>
        <div style="margin-top: 20px; font-size: 12px; color: #555;">GPU ACCELERATION REQUIRED</div>
    </div>

    <div class="hud-info" style="top: 20px; left: 20px;">
        SYS.STATUS: <span style="color:#fff">ONLINE</span><br>
        SECURITY: <span style="color:#fff">MAXIMUM</span>
    </div>
    <div class="hud-info" style="bottom: 20px; right: 20px; text-align: right;">
        MK.42 HOLOGRAPHIC UI<br>
        <span id="coords">X:000 Y:000 Z:000</span>
    </div>

    <video class="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, composer, controls;
        let hologramGroup, globePoints, coreSphere;
        const rings = [];
        
        // 状态
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isHandActive = false;

        // 初始化
        function init() {
            // 隐藏 Loading
            const loader = document.getElementById('loader');
            loader.style.transition = 'opacity 0.8s';
            loader.style.opacity = 0;
            setTimeout(() => loader.style.display = 'none', 800);

            // 1. 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); // 黑色雾气增加深邃感

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 35); // 相机拉远

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // 开启物理光照模拟
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // 2. 后期处理 (Bloom是电影感的关键)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 2.5; // 极强的辉光
            bloomPass.radius = 0.8;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 3. 鼠标控制 (备用)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true; // 默认自动旋转
            controls.autoRotateSpeed = 0.5;

            // 4. 构建场景对象
            buildScene();

            // 5. 事件监听
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);

            // 6. 循环
            animate();
            
            // 7. 启动摄像头
            initCamera();
        }

        // --- 核心场景构建 (这里是重头戏) ---
        function buildScene() {
            hologramGroup = new THREE.Group();
            scene.add(hologramGroup);

            // 材质库
            const blueMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.1, blending: THREE.AdditiveBlending });
            const brightMat = new THREE.LineBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            
            // A. 点云地球 (核心)
            // 这种看起来像《钢铁侠2》里发现新元素的场景
            const globeGeo = new THREE.IcosahedronGeometry(10, 4); // 高精度
            const globePos = globeGeo.attributes.position.array;
            const pts = [];
            for (let i = 0; i < globePos.length; i += 3) {
                // 随机剔除一些点，做成数据破碎感
                if (Math.random() > 0.2) {
                    pts.push(globePos[i], globePos[i+1], globePos[i+2]);
                }
            }
            const particlesGeo = new THREE.BufferGeometry();
            particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
            const particlesMat = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.15,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            globePoints = new THREE.Points(particlesGeo, particlesMat);
            hologramGroup.add(globePoints);

            // B. 内部核心球体 (线框)
            const coreGeo = new THREE.SphereGeometry(6, 32, 32);
            coreSphere = new THREE.Mesh(coreGeo, blueMat);
            hologramGroup.add(coreSphere);

            // C. 生成大量的数据圆环 (JARVIS 经典视觉)
            function createDataRing(radius, type) {
                const ringGroup = new THREE.Group();
                let geo, mesh;

                if (type === 'simple') {
                    geo = new THREE.TorusGeometry(radius, 0.02, 16, 100);
                    mesh = new THREE.Mesh(geo, brightMat);
                } else if (type === 'dashed') {
                    // 虚线环逻辑
                    const curve = new THREE.EllipseCurve(0, 0, radius, radius, 0, 2 * Math.PI, false, 0);
                    const points = curve.getPoints(100);
                    geo = new THREE.BufferGeometry().setFromPoints(points);
                    mesh = new THREE.Line(geo, new THREE.LineDashedMaterial({ color: 0x00ffff, dashSize: 1, gapSize: 0.5, scale: 1 }));
                    mesh.computeLineDistances();
                } else if (type === 'ticks') {
                    // 刻度环
                    geo = new THREE.BufferGeometry();
                    const positions = [];
                    const count = 60;
                    for(let i=0; i<count; i++) {
                        const angle = (i/count) * Math.PI * 2;
                        const rIn = radius;
                        const rOut = radius + 0.5;
                        positions.push(Math.cos(angle)*rIn, Math.sin(angle)*rIn, 0);
                        positions.push(Math.cos(angle)*rOut, Math.sin(angle)*rOut, 0);
                    }
                    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    mesh = new THREE.LineSegments(geo, brightMat);
                }
                
                ringGroup.add(mesh);
                // 随机倾斜一点，增加立体感
                ringGroup.rotation.x = Math.random() * 0.5;
                ringGroup.rotation.y = Math.random() * 0.5;
                
                hologramGroup.add(ringGroup);
                
                // 存入数组用于动画
                rings.push({
                    mesh: ringGroup,
                    speed: (Math.random() - 0.5) * 0.02, // 随机转速
                    axis: Math.random() > 0.5 ? 'x' : 'y'
                });
            }

            // 生成不同半径的环
            createDataRing(11, 'ticks');
            createDataRing(11.5, 'simple');
            createDataRing(13, 'dashed');
            createDataRing(14, 'simple');
            createDataRing(16, 'ticks');
            createDataRing(18, 'dashed');

            // D. 背景星空粒子 (增加景深)
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                starPos[i] = (Math.random() - 0.5) * 100;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1, transparent: true, opacity: 0.5});
            const stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // 1. 核心动画
            globePoints.rotation.y += 0.002;
            coreSphere.rotation.y -= 0.005;
            
            // 呼吸效果
            const scale = 1 + Math.sin(time) * 0.05;
            coreSphere.scale.set(scale, scale, scale);

            // 2. 圆环动画
            rings.forEach(ring => {
                if (ring.axis === 'x') ring.mesh.rotation.x += ring.speed;
                else ring.mesh.rotation.y += ring.speed;
                
                // 甚至让环也要自转
                ring.mesh.rotation.z += 0.001;
            });

            // 3. 手势控制逻辑
            if (isHandActive) {
                // 平滑过渡到手势目标
                hologramGroup.rotation.y += (targetRotationY - hologramGroup.rotation.y) * 0.1;
                hologramGroup.rotation.x += (targetRotationX - hologramGroup.rotation.x) * 0.1;
                controls.enabled = false; // 禁用鼠标
            } else {
                controls.enabled = true; // 启用鼠标
                controls.update(); // 自动旋转
            }

            composer.render();
            
            // 更新 UI 数字
            document.getElementById('coords').innerText = 
                `X:${hologramGroup.rotation.x.toFixed(2)} Y:${hologramGroup.rotation.y.toFixed(2)}`;
        }

        // --- 摄像头与手势 ---
        function initCamera() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isHandActive = true;
                    const landmarks = results.multiHandLandmarks[0];
                    const x = landmarks[9].x; // 0-1
                    const y = landmarks[9].y; // 0-1
                    
                    // 将手的位置映射到旋转角度
                    // X 控制 Y轴旋转 (左右挥手 = 左右转)
                    targetRotationY = (x - 0.5) * 5; 
                    // Y 控制 X轴旋转 (上下挥手 = 上下翻转)
                    targetRotationX = (y - 0.5) * 5;

                } else {
                    isHandActive = false;
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        // 辅助事件
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        document.getElementById('startBtn').addEventListener('click', init);

    </script>
</body>
</html>